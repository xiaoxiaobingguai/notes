(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{178:function(a,e,t){"use strict";t.r(e);var s=t(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"前端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端")]),a._v(" "),t("h2",{attrs:{id:"npx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npx","aria-hidden":"true"}},[a._v("#")]),a._v(" npx")]),a._v(" "),t("p",[a._v("npm 从 5.2 版开始，增加了 npx 命令。它有不少用处，但很多人其实又不知道它是个什么，该如何正确的使用它。")]),a._v(" "),t("p",[a._v("Node 自带 npm 模块。所以你只要安装了 node，你就可以直接使用它了，不需要什么额外的操作。")]),a._v(" "),t("h3",{attrs:{id:"方便调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方便调用","aria-hidden":"true"}},[a._v("#")]),a._v(" 方便调用")]),a._v(" "),t("p",[a._v("npx 第一个好处就是方便的调用了项目内部安装的模块。比如我项目内安装了测试工具 Mocha。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm install -D mocha\n")])])]),t("p",[a._v("般来说，调用 Mocha ，只能在项目脚本和 package.json 的 scripts 字段里面， 如果想在命令行下调用，必须像下面这样。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("# 项目的根目录下执行\nnode-modules/.bin/mocha\n")])])]),t("p",[a._v("npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("npx mocha\n")])])]),t("p",[a._v("它的原理也很简单。就死运行的时候会到"),t("code",[a._v("node_modules/.bin")]),a._v("路径和环境变量"),t("code",[a._v("$PATH")]),a._v("里面，检查命令是否存在。")]),a._v(" "),t("h3",{attrs:{id:"避免全局安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#避免全局安装","aria-hidden":"true"}},[a._v("#")]),a._v(" 避免全局安装")]),a._v(" "),t("p",[a._v("第二个好处就是可以避免全局安装模块。比如，你要用 react 的脚手架"),t("code",[a._v("create-react-app")]),a._v("它是需要全局安装的，但你其实也只有在初始化的时候需要用到它，大部分时间它是使用不到的。\n但用了 npx 之后，就不需要全局安装它了。你可以使用 npx 直接运行它。")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("npx create-react-app my-react-app\n")])])]),t("p",[a._v("上面代码运行时，npx 将"),t("code",[a._v("create-react-app")]),a._v("下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载 "),t("code",[a._v("create-react-app")]),a._v("。")]),a._v(" "),t("h3",{attrs:{id:"指定版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指定版本","aria-hidden":"true"}},[a._v("#")]),a._v(" 指定版本")]),a._v(" "),t("p",[a._v("npx 还有一个好处，就是你可以指定你要运行模块的版本。比如你本地环境是 node10 的，但你想用 node11 的环境执行一段脚本。(当然你也可以 nvm 本地管理多个 node 版本)")]),a._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[a._v("npx -p node@11.9.0 node -v\n")])])]),t("h2",{attrs:{id:"virtual-dom-性能好？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-性能好？","aria-hidden":"true"}},[a._v("#")]),a._v(" Virtual DOM 性能好？")]),a._v(" "),t("p",[a._v("每次面试，面试人一谈到 react 就必然会谈到 Virtual DOM，一谈到 Virtual DOM 就会说它比原生操作 DOM 性能哪里哪里好。")]),a._v(" "),t("p",[a._v("但任何一个 v-dom 框架都不会说自己的性能快过 DOM 操作。就拿 react 为例子，它的目标是：“每次数据变化都以最小的代价来更新真实 DOM”。引入 v-dom，在内存中比较虚拟节点，然后找出不同，之后执行更新。")]),a._v(" "),t("p",[a._v("就能更改页面上一个元素的内容，直接操作 DOM 的反应速度绝对会比你 diff 一次之后再更新来的快。但这时你可能会觉得当程序到达一定的复杂度之后，v-dom 性能上的优势才能体现出来。但是，无论你代价再少也好，v-dom 都是有消耗的，光从你要生成整个页面的 v-dom 就会比单单生成原生 dom 要多消耗一大截内存，更别说其中的复杂递归，比对，然后再变换。但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。")]),a._v(" "),t("p",[a._v("所以 v-dom 真正的价值是什么？")]),a._v(" "),t("p",[a._v("框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。")]),a._v(" "),t("p",[a._v("我认为是带来了跨屏能力，以及代码的可维护性， 同时为函数式的 UI 编程方式打开了大门。")])])}],!1,null,null,null);e.default=r.exports}}]);